<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>State Machine Development Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #ffffff;
            display: flex;
            gap: 20px;
        }
        
        #gameContainer {
            flex: 1;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .controls {
            width: 300px;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background: #333;
            border-radius: 5px;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }
        
        .status {
            padding: 8px;
            margin: 5px 0;
            background: #444;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .status.active {
            background: #4CAF50;
            color: #000;
        }
        
        .status.transitioning {
            background: #FF9800;
            color: #000;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .state-diagram {
            background: #222;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
        }
        
        .state-node {
            display: inline-block;
            padding: 8px 12px;
            margin: 5px;
            border-radius: 20px;
            background: #555;
            border: 2px solid #777;
        }
        
        .state-node.active {
            background: #4CAF50;
            border-color: #66BB6A;
            color: #000;
        }
        
        .state-node.previous {
            background: #FF9800;
            border-color: #FFB74D;
            color: #000;
        }
        
        .transition-arrow {
            color: #888;
            margin: 0 5px;
        }
        
        .debug-log {
            background: #111;
            padding: 10px;
            border-radius: 5px;
            height: 200px;
            overflow-y: auto;
            font-size: 12px;
            border: 1px solid #333;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .log-entry.info { background: #1a3a1a; }
        .log-entry.warning { background: #3a2a1a; }
        .log-entry.error { background: #3a1a1a; }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    
    <div class="controls">
        <div class="control-group">
            <h3>State Machine Test</h3>
            <div class="status" id="currentState">Current State: Idle</div>
            <div class="status" id="previousState">Previous State: None</div>
            <div class="status" id="stateTimer">State Timer: 0ms</div>
        </div>
        
        
        <div class="control-group">
            <h3>Timers</h3>
            <div class="status" id="boostTimer">Boost Timer: 0ms</div>
            <div class="status" id="boostJumpTimer">Boost Jump Timer: 0ms</div>
            <div class="status" id="groundSlideTimer">Ground Slide Timer: 0ms</div>
            <div class="status" id="chargeLevel">Charge Level: 0%</div>
            <div class="status" id="boostChains">Boost Chains: 0/2</div>
        </div>
        
    </div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <script>
        // State Machine Framework
        class StateMachine {
            constructor() {
                this.states = new Map();
                this.currentState = null;
                this.previousState = null;
                this.stateTimer = 0;
                this.transitions = new Map();
            }
            
            addState(name, state) {
                this.states.set(name, state);
            }
            
            addTransition(from, to, condition) {
                if (!this.transitions.has(from)) {
                    this.transitions.set(from, []);
                }
                this.transitions.get(from).push({ to, condition });
            }
            
            setState(newState) {
                if (this.currentState === newState) {
                    return;
                }
                
                if (!this.states.has(newState)) {
                    return;
                }
                
                // Exit current state
                if (this.currentState) {
                    const currentStateObj = this.states.get(this.currentState);
                    if (currentStateObj && currentStateObj.onExit) {
                        currentStateObj.onExit();
                    }
                    this.previousState = this.currentState;
                }
                
                // Enter new state
                this.currentState = newState;
                this.stateTimer = 0;
                
                const newStateObj = this.states.get(newState);
                if (newStateObj && newStateObj.onEnter) {
                    newStateObj.onEnter();
                }
                
                this.updateUI();
            }
            
            update(delta) {
                if (this.currentState) {
                    this.stateTimer += delta;
                    
                    const stateObj = this.states.get(this.currentState);
                    if (stateObj && stateObj.onUpdate) {
                        stateObj.onUpdate(delta);
                    }
                    
                    // Check for automatic transitions
                    this.checkTransitions();
                }
            }
            
            checkTransitions() {
                if (!this.currentState || !this.transitions.has(this.currentState)) {
                    return;
                }
                
                const possibleTransitions = this.transitions.get(this.currentState);
                for (const transition of possibleTransitions) {
                    if (transition.condition()) {
                        this.setState(transition.to);
                        break;
                    }
                }
            }
            
            
            updateUI() {
                // Update current state display
                document.getElementById('currentState').textContent = `Current State: ${this.currentState || 'None'}`;
                document.getElementById('currentState').className = this.currentState ? 'status active' : 'status';
                
                // Update previous state display
                document.getElementById('previousState').textContent = `Previous State: ${this.previousState || 'None'}`;
                
                // Update state timer
                document.getElementById('stateTimer').textContent = `State Timer: ${Math.round(this.stateTimer)}ms`;
                
                // Update state diagram
                this.updateStateDiagram();
            }
            
            updateStateDiagram() {
                // Reset all nodes
                document.querySelectorAll('.state-node').forEach(node => {
                    node.className = 'state-node';
                });
                
                // Highlight current state
                if (this.currentState) {
                    const currentNode = document.getElementById(`node-${this.currentState}`);
                    if (currentNode) {
                        currentNode.className = 'state-node active';
                    }
                }
                
                // Highlight previous state
                if (this.previousState) {
                    const previousNode = document.getElementById(`node-${this.previousState}`);
                    if (previousNode) {
                        previousNode.className = 'state-node previous';
                    }
                }
            }
        }
        
        // Example States
        class IdleState {
            onEnter() {
                console.log('Entering Idle state');
            }
            
            onUpdate(delta) {
                // Idle state logic
            }
            
            onExit() {
                console.log('Exiting Idle state');
            }
        }
        
        class MovingState {
            constructor(scene) {
                this.scene = scene;
            }
            
            onEnter() {
                console.log('Entering Moving state');
            }
            
            onUpdate(delta) {
                // Handle horizontal movement
                const leftPressed = this.scene.inputKeys.LEFT.isDown;
                const rightPressed = this.scene.inputKeys.RIGHT.isDown;
                
                if (leftPressed) {
                    this.scene.character.setVelocityX(-this.scene.walkSpeed);
                    this.scene.facingRight = false;
                    this.scene.character.setFlipX(true);
                } else if (rightPressed) {
                    this.scene.character.setVelocityX(this.scene.walkSpeed);
                    this.scene.facingRight = true;
                    this.scene.character.setFlipX(false);
                } else {
                    // Apply friction
                    this.scene.character.setVelocityX(this.scene.character.body.velocity.x * 0.8);
                }
            }
            
            onExit() {
                console.log('Exiting Moving state');
            }
        }
        
        class JumpingState {
            constructor(scene) {
                this.scene = scene;
            }
            
            onEnter() {
                console.log('Entering Jumping state');
                // Apply jump velocity
                this.scene.character.setVelocityY(-this.scene.jumpVelocity);
            }
            
            onUpdate(delta) {
                // Handle horizontal movement while jumping
                const leftPressed = this.scene.inputKeys.LEFT.isDown;
                const rightPressed = this.scene.inputKeys.RIGHT.isDown;
                
                if (leftPressed) {
                    this.scene.character.setVelocityX(-this.scene.walkSpeed * 0.7); // Reduced air control
                    this.scene.facingRight = false;
                    this.scene.character.setFlipX(true);
                } else if (rightPressed) {
                    this.scene.character.setVelocityX(this.scene.walkSpeed * 0.7);
                    this.scene.facingRight = true;
                    this.scene.character.setFlipX(false);
                }
            }
            
            onExit() {
                console.log('Exiting Jumping state');
            }
        }
        
        class GroundSlideState {
            constructor(scene) {
                this.scene = scene;
            }
            
            onEnter() {
                console.log('Entering Ground Slide state');
                // Consume boost chain (matching actual controller)
                this.scene.boostChains++;
                if (this.scene.boostChains >= this.scene.maxBoostChains) {
                    this.scene.flags.boost = false;
                    this.scene.boostTimer = 0;
                    this.scene.boostChains = 0;
                }
                this.scene.flags.boosted = true;
                this.scene.groundSlideTimer = this.scene.groundSlideDuration;
            }
            
            onUpdate(delta) {
                // Ground slide movement - fast horizontal movement
                const direction = this.scene.facingRight ? 1 : -1;
                const slideSpeed = this.scene.walkSpeed * 2; // Double speed for slide
                this.scene.character.setVelocityX(slideSpeed * direction);
                this.scene.character.setVelocityY(0); // Keep on ground
                
                // Shrink character during slide
                this.scene.character.setScale(1, 0.5);
            }
            
            onExit() {
                console.log('Exiting Ground Slide state');
                this.scene.flags.boosted = false;
                // Restore character size
                this.scene.character.setScale(1, 2);
            }
        }
        
        class BoostJumpState {
            constructor(scene) {
                this.scene = scene;
            }
            
            onEnter() {
                console.log('Entering Boost Jump state');
                // Consume boost chain (matching actual controller)
                this.scene.boostChains++;
                if (this.scene.boostChains >= this.scene.maxBoostChains) {
                    this.scene.flags.boost = false;
                    this.scene.boostTimer = 0;
                    this.scene.boostChains = 0;
                }
                this.scene.flags.boosted = true;
                this.scene.boostJumpTimer = this.scene.boostJumpDuration;
            }
            
            onUpdate(delta) {
                // Boost jump state logic
            }
            
            onExit() {
                console.log('Exiting Boost Jump state');
                this.scene.flags.boosted = false;
            }
        }
        
        class ChargeJumpState {
            constructor(scene) {
                this.scene = scene;
            }
            
            onEnter() {
                console.log('Entering Charge Jump state');
                // Consume charge boost (matching actual controller)
                this.scene.flags.charge = false;
                this.scene.flags.chargeFull = false;
                this.scene.chargeLevel = 0;
                this.scene.flags.boosted = true;
                this.scene.boostJumpTimer = this.scene.boostJumpDuration;
            }
            
            onUpdate(delta) {
                // Charge jump state logic
            }
            
            onExit() {
                console.log('Exiting Charge Jump state');
                this.scene.flags.boosted = false;
            }
        }
        
        // Game Scene
        class StateMachineTestScene extends Phaser.Scene {
            constructor() {
                super({ key: 'StateMachineTestScene' });
                this.stateMachine = new StateMachine();
                this.inputKeys = {};
                this.flags = {
                    grounded: true,
                    falling: false,
                    raising: false,
                    boost: false,
                    boosting: false,
                    charge: false,
                    chargeFull: false,
                    boosted: false
                };
                
                // Boost system (matching actual controller)
                this.boostTimer = 0;
                this.boostDuration = 400; // 400ms boost window
                this.boostChains = 0; // Track how many boost actions used
                this.maxBoostChains = 2; // Allow boost -> dash -> boost jump
                this.boostVelocityMultiplier = 1.5; // Speed boost when boosted
                this.initialBoostApplied = false; // Track if initial boost was applied
                
                // Charge boost system
                this.isChargeBoosting = false; // Charge boost state
                this.chargeLevel = 0; // 0-100 charge level
                this.maxChargeLevel = 100; // Maximum charge level
                this.chargeRate = 100 / 1500; // Charge per ms (100 charge in 1500ms)
                
                // Jump timers
                this.boostJumpTimer = 0;
                this.boostJumpDuration = 300; // 300ms boost jump duration
                this.groundSlideTimer = 0;
                this.groundSlideDuration = 600; // 600ms ground slide duration (3x dash duration)
            }
            
            preload() {
                // Create simple colored rectangles for the character
                let graphics = this.add.graphics()
                    .fillStyle(0x4A90E2)
                    .fillRect(0, 0, 32, 64);
                graphics.generateTexture('player', 32, 64);
                graphics.destroy();
            }
            
            create() {
                // Create physics character sprite
                this.character = this.physics.add.sprite(400, 300, 'player');
                this.character.setCollideWorldBounds(true);
                this.character.setBounce(0);
                this.character.setScale(1, 2); // Double height
                this.character.setOrigin(0.5, 1.0); // Scale from bottom
                
                // Create visual aids for character
                this.createCharacterVisualAids();
                
                // Create ground plane
                this.createGroundPlane();
                
                // Create original rectangle in center of key map
                this.originalRectangle = this.add.rectangle(500, 450, 32, 16, 0x4CAF50);
                this.originalRectangle.setStrokeStyle(2, 0x66BB6A);
                
                // Create direction arrow for character
                this.characterDirectionArrow = this.add.graphics();
                
                // Create direction arrow for key indicators
                this.directionArrow = this.add.graphics();
                
                // Create key press indicators
                this.createKeyIndicators();
                
                // Create flag indicators
                this.createFlagIndicators();
                
                // Initialize state machine
                this.setupStateMachine();
                this.setupControls();
                
                // Start with idle state
                this.stateMachine.setState('idle');
                
                // Movement properties
                this.walkSpeed = 200;
                this.jumpVelocity = 400;
                this.isGrounded = false;
                this.facingRight = true;
            }
            
            createCharacterVisualAids() {
                // Visual box for lowest part (feet) - now at ground level
                this.feetBox = this.add.rectangle(400, 316, 28, 8, 0xff0000);
                this.feetBox.setStrokeStyle(1, 0xffffff);
                this.feetBox.setAlpha(0.7);
                
                // Visual aid for center - adjusted for new character position
                this.centerBox = this.add.rectangle(400, 284, 24, 4, 0xffff00);
                this.centerBox.setStrokeStyle(1, 0xffffff);
                this.centerBox.setAlpha(0.7);
            }
            
            createGroundPlane() {
                // Ground plane line (1/3 width, centered) using graphics
                this.groundGraphics = this.add.graphics();
                this.groundGraphics.lineStyle(3, 0x888888);
                this.groundGraphics.beginPath();
                this.groundGraphics.moveTo(267, 316); // Start at 1/3 from left, moved down 30px
                this.groundGraphics.lineTo(533, 316); // End at 2/3 from left, moved down 30px
                this.groundGraphics.strokePath();
                
                // Ground plane label
                this.add.text(400, 326, 'GROUND', {
                    fontSize: '14px',
                    color: '#888888',
                    align: 'center'
                }).setOrigin(0.5, 0.5);
            }
            
            createKeyIndicators() {
                this.keyIndicators = {};
                const keyPositions = {
                    'UP': { x: 500, y: 400 },
                    'DOWN': { x: 500, y: 500 },
                    'LEFT': { x: 450, y: 450 },
                    'RIGHT': { x: 550, y: 450 },
                    'SPACE': { x: 600, y: 400 },
                    'SHIFT': { x: 600, y: 450 }
                };
                
                Object.keys(keyPositions).forEach(key => {
                    const pos = keyPositions[key];
                    this.keyIndicators[key] = this.add.circle(pos.x, pos.y, 15, 0x333333);
                    this.keyIndicators[key].setStrokeStyle(2, 0x666666);
                    
                    // Add key label
                    this.add.text(pos.x, pos.y, key, {
                        fontSize: '10px',
                        color: '#ffffff',
                        align: 'center'
                    }).setOrigin(0.5);
                });
            }
            
            createFlagIndicators() {
                this.flagIndicators = {};
                const flagPositions = {
                    'GROUNDED': { x: 50, y: 50 },
                    'FALLING': { x: 50, y: 80 },
                    'RAISING': { x: 50, y: 110 },
                    'BOOST': { x: 50, y: 140 },
                    'BOOSTING': { x: 50, y: 170 },
                    'BOOSTED': { x: 50, y: 200 },
                    'CHARGE': { x: 50, y: 230 },
                    'CHARGE_FULL': { x: 50, y: 260 }
                };
                
                Object.keys(flagPositions).forEach(flag => {
                    const pos = flagPositions[flag];
                    this.flagIndicators[flag] = this.add.rectangle(pos.x, pos.y, 20, 20, 0x333333);
                    this.flagIndicators[flag].setStrokeStyle(2, 0x666666);
                    
                    // Add flag label
                    this.add.text(pos.x + 30, pos.y, flag, {
                        fontSize: '12px',
                        color: '#ffffff',
                        align: 'left'
                    }).setOrigin(0, 0.5);
                });
            }
            
            setupStateMachine() {
                // Add states
                this.stateMachine.addState('idle', new IdleState(this));
                this.stateMachine.addState('moving', new MovingState(this));
                this.stateMachine.addState('jumping', new JumpingState(this));
                this.stateMachine.addState('boost-jump', new BoostJumpState(this));
                this.stateMachine.addState('charge-jump', new ChargeJumpState(this));
                this.stateMachine.addState('groundslide', new GroundSlideState(this));
                
                // Add transitions with conditions
                this.stateMachine.addTransition('idle', 'moving', () => {
                    return this.isAnyMovementKeyPressed();
                });
                
                this.stateMachine.addTransition('moving', 'idle', () => {
                    return !this.isAnyMovementKeyPressed();
                });
                
                this.stateMachine.addTransition('idle', 'jumping', () => {
                    return Phaser.Input.Keyboard.JustDown(this.inputKeys.SPACE) && this.flags.grounded && !this.flags.boost && !this.flags.charge;
                });
                
                this.stateMachine.addTransition('moving', 'jumping', () => {
                    return Phaser.Input.Keyboard.JustDown(this.inputKeys.SPACE) && this.flags.grounded && !this.flags.boost && !this.flags.charge;
                });
                
                this.stateMachine.addTransition('idle', 'boost-jump', () => {
                    return Phaser.Input.Keyboard.JustDown(this.inputKeys.SPACE) && this.flags.grounded && this.flags.boost && this.boostChains < this.maxBoostChains;
                });
                
                this.stateMachine.addTransition('moving', 'boost-jump', () => {
                    return Phaser.Input.Keyboard.JustDown(this.inputKeys.SPACE) && this.flags.grounded && this.flags.boost && this.boostChains < this.maxBoostChains;
                });
                
                this.stateMachine.addTransition('idle', 'charge-jump', () => {
                    return Phaser.Input.Keyboard.JustDown(this.inputKeys.SPACE) && this.flags.grounded && this.flags.charge;
                });
                
                this.stateMachine.addTransition('moving', 'charge-jump', () => {
                    return Phaser.Input.Keyboard.JustDown(this.inputKeys.SPACE) && this.flags.grounded && this.flags.charge;
                });
                
                this.stateMachine.addTransition('jumping', 'idle', () => {
                    return this.flags.grounded && !this.flags.raising;
                });
                
                this.stateMachine.addTransition('jumping', 'moving', () => {
                    return this.flags.grounded && !this.flags.raising && this.isAnyMovementKeyPressed();
                });
                
                this.stateMachine.addTransition('boost-jump', 'idle', () => {
                    return this.boostJumpTimer <= 0;
                });
                
                this.stateMachine.addTransition('boost-jump', 'moving', () => {
                    return this.boostJumpTimer <= 0 && this.isAnyMovementKeyPressed();
                });
                
                this.stateMachine.addTransition('charge-jump', 'idle', () => {
                    return this.boostJumpTimer <= 0;
                });
                
                this.stateMachine.addTransition('charge-jump', 'moving', () => {
                    return this.boostJumpTimer <= 0 && this.isAnyMovementKeyPressed();
                });
                
                this.stateMachine.addTransition('idle', 'groundslide', () => {
                    return this.isGroundSlidePressed() && this.flags.grounded && this.flags.boost;
                });
                
                this.stateMachine.addTransition('moving', 'groundslide', () => {
                    return this.isGroundSlidePressed() && this.flags.grounded && this.flags.boost;
                });
                
                this.stateMachine.addTransition('groundslide', 'idle', () => {
                    return this.groundSlideTimer <= 0;
                });
                
                this.stateMachine.addTransition('groundslide', 'moving', () => {
                    return this.groundSlideTimer <= 0 && this.isAnyMovementKeyPressed();
                });
            }
            
            setupControls() {
                // Create input keys
                this.inputKeys = {
                    UP: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP),
                    DOWN: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.DOWN),
                    LEFT: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.LEFT),
                    RIGHT: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.RIGHT),
                    SPACE: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),
                    SHIFT: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT)
                };
                
            }
            
            isAnyMovementKeyPressed() {
                return this.inputKeys.UP.isDown || this.inputKeys.DOWN.isDown || 
                       this.inputKeys.LEFT.isDown || this.inputKeys.RIGHT.isDown;
            }
            
            isGroundSlidePressed() {
                return this.inputKeys.SHIFT.isDown && this.inputKeys.DOWN.isDown;
            }
            
            getDirectionVector() {
                let x = 0, y = 0;
                
                if (this.inputKeys.LEFT.isDown) x -= 1;
                if (this.inputKeys.RIGHT.isDown) x += 1;
                if (this.inputKeys.UP.isDown) y -= 1;
                if (this.inputKeys.DOWN.isDown) y += 1;
                
                // Normalize diagonal movement
                if (x !== 0 && y !== 0) {
                    x *= 0.707; // 1/sqrt(2)
                    y *= 0.707;
                }
                
                return { x, y };
            }
            
            update(time, delta) {
                // Update ground detection
                this.isGrounded = this.character.body.touching.down;
                
                // Update timers
                this.updateTimers(delta);
                
                // Update state machine
                this.stateMachine.update(delta);
                
                // Update visual feedback
                this.updateKeyIndicators();
                this.updateFlagIndicators();
                this.updateDirectionArrow();
                this.updateCharacterDirectionArrow();
                this.updateFlags(delta);
                
                // Update timer displays
                this.updateTimerDisplays();
            }
            
            updateTimerDisplays() {
                document.getElementById('boostTimer').textContent = `Boost Timer: ${Math.ceil(this.boostTimer)}ms`;
                document.getElementById('boostJumpTimer').textContent = `Boost Jump Timer: ${Math.ceil(this.boostJumpTimer)}ms`;
                document.getElementById('groundSlideTimer').textContent = `Ground Slide Timer: ${Math.ceil(this.groundSlideTimer)}ms`;
                document.getElementById('chargeLevel').textContent = `Charge Level: ${Math.round(this.chargeLevel)}%`;
                document.getElementById('boostChains').textContent = `Boost Chains: ${this.boostChains}/${this.maxBoostChains}`;
            }
            
            updateTimers(delta) {
                // Update boost timer (matching actual controller)
                if (this.boostTimer > 0) {
                    this.boostTimer -= delta;
                    if (this.boostTimer <= 0) {
                        console.log("Boost timer expired! Shift held:", this.inputKeys.SHIFT.isDown, "Already charge boosting:", this.isChargeBoosting);
                        // Check if boost key is still held for charge boost transition
                        const boostHeld = this.inputKeys.SHIFT.isDown;
                        if (boostHeld && !this.isChargeBoosting) {
                            console.log("Transitioning to charge boost mode!");
                            this.isChargeBoosting = true;
                            this.flags.boost = false; // Exit boost mode
                            this.chargeLevel = 0;
                            this.boostChains = 0;
                            this.initialBoostApplied = false;
                        } else {
                            console.log("Not transitioning to charge boost - Shift held:", boostHeld, "Already charge boosting:", this.isChargeBoosting);
                            this.flags.boost = false;
                            this.boostChains = 0;
                            this.initialBoostApplied = false;
                        }
                    }
                }
                
                // Update charge boost timer
                if (this.isChargeBoosting) {
                    // Build up charge
                    this.chargeLevel = Math.min(this.maxChargeLevel, this.chargeLevel + (this.chargeRate * delta));
                }
                
                // Update boost jump timer
                if (this.boostJumpTimer > 0) {
                    this.boostJumpTimer -= delta;
                    if (this.boostJumpTimer <= 0) {
                        this.flags.boosted = false;
                    }
                }
                
                // Update ground slide timer
                if (this.groundSlideTimer > 0) {
                    this.groundSlideTimer -= delta;
                }
            }
            
            updateKeyIndicators() {
                Object.keys(this.inputKeys).forEach(key => {
                    const isPressed = this.inputKeys[key].isDown;
                    const indicator = this.keyIndicators[key];
                    
                    if (isPressed) {
                        indicator.setFillStyle(0x4CAF50);
                        indicator.setStrokeStyle(2, 0x66BB6A);
                    } else {
                        indicator.setFillStyle(0x333333);
                        indicator.setStrokeStyle(2, 0x666666);
                    }
                });
            }
            
            updateFlagIndicators() {
                const flagMapping = {
                    'grounded': 'GROUNDED',
                    'falling': 'FALLING',
                    'raising': 'RAISING',
                    'boost': 'BOOST',
                    'boosting': 'BOOSTING',
                    'boosted': 'BOOSTED',
                    'charge': 'CHARGE',
                    'chargeFull': 'CHARGE_FULL'
                };
                
                Object.keys(this.flags).forEach(flag => {
                    const isActive = this.flags[flag];
                    const indicatorKey = flagMapping[flag];
                    const indicator = this.flagIndicators[indicatorKey];
                    
                    if (indicator) {
                        if (isActive) {
                            indicator.setFillStyle(0x4CAF50);
                            indicator.setStrokeStyle(2, 0x66BB6A);
                        } else {
                            indicator.setFillStyle(0x333333);
                            indicator.setStrokeStyle(2, 0x666666);
                        }
                    }
                });
            }
            
            updateDirectionArrow() {
                this.directionArrow.clear();
                
                const direction = this.getDirectionVector();
                if (direction.x !== 0 || direction.y !== 0) {
                    const arrowLength = 50;
                    const startX = this.originalRectangle.x;
                    const startY = this.originalRectangle.y;
                    const endX = startX + (direction.x * arrowLength);
                    const endY = startY + (direction.y * arrowLength);
                    
                    // Draw arrow line
                    this.directionArrow.lineStyle(4, 0xffff00);
                    this.directionArrow.beginPath();
                    this.directionArrow.moveTo(startX, startY);
                    this.directionArrow.lineTo(endX, endY);
                    this.directionArrow.strokePath();
                    
                    // Draw arrow head
                    const headSize = 8;
                    const angle = Math.atan2(direction.y, direction.x);
                    
                    this.directionArrow.lineStyle(4, 0xffff00);
                    this.directionArrow.beginPath();
                    this.directionArrow.moveTo(endX, endY);
                    this.directionArrow.lineTo(
                        endX - headSize * Math.cos(angle - Math.PI / 6),
                        endY - headSize * Math.sin(angle - Math.PI / 6)
                    );
                    this.directionArrow.moveTo(endX, endY);
                    this.directionArrow.lineTo(
                        endX - headSize * Math.cos(angle + Math.PI / 6),
                        endY - headSize * Math.sin(angle + Math.PI / 6)
                    );
                    this.directionArrow.strokePath();
                }
            }
            
            updateCharacterDirectionArrow() {
                this.characterDirectionArrow.clear();
                
                const direction = this.getDirectionVector();
                if (direction.x !== 0 || direction.y !== 0) {
                    const arrowLength = 50;
                    const startX = this.character.x;
                    const startY = this.character.y; // Start from center of character
                    const endX = startX + (direction.x * arrowLength);
                    const endY = startY + (direction.y * arrowLength);
                    
                    // Draw arrow line
                    this.characterDirectionArrow.lineStyle(3, 0xff0000);
                    this.characterDirectionArrow.beginPath();
                    this.characterDirectionArrow.moveTo(startX, startY);
                    this.characterDirectionArrow.lineTo(endX, endY);
                    this.characterDirectionArrow.strokePath();
                    
                    // Draw arrow head
                    const headSize = 6;
                    const angle = Math.atan2(direction.y, direction.x);
                    
                    this.characterDirectionArrow.lineStyle(3, 0xff0000);
                    this.characterDirectionArrow.beginPath();
                    this.characterDirectionArrow.moveTo(endX, endY);
                    this.characterDirectionArrow.lineTo(
                        endX - headSize * Math.cos(angle - Math.PI / 6),
                        endY - headSize * Math.sin(angle - Math.PI / 6)
                    );
                    this.characterDirectionArrow.moveTo(endX, endY);
                    this.characterDirectionArrow.lineTo(
                        endX - headSize * Math.cos(angle + Math.PI / 6),
                        endY - headSize * Math.sin(angle + Math.PI / 6)
                    );
                    this.characterDirectionArrow.strokePath();
                }
            }
            
            updateFlags(delta) {
                // Handle boost activation (matching actual controller)
                if (Phaser.Input.Keyboard.JustDown(this.inputKeys.SHIFT)) {
                    this.flags.boost = true;
                    this.isChargeBoosting = false;
                    this.chargeLevel = 0;
                    this.boostTimer = this.boostDuration;
                    this.initialBoostApplied = false;
                    console.log("Starting boost mode!");
                }
                
                // Handle charge boost release (matching actual controller)
                if (this.isChargeBoosting && !this.inputKeys.SHIFT.isDown) {
                    console.log("Releasing charge boost! Level:", Math.round(this.chargeLevel));
                    this.isChargeBoosting = false;
                    this.flags.boost = false;
                    this.chargeLevel = 0;
                }
                
                // Update boost flags
                this.flags.boosting = this.flags.boost && this.stateMachine.currentState === 'moving';
                
                // Update charge flags (matching actual controller logic)
                this.flags.charge = this.isChargeBoosting;
                this.flags.chargeFull = this.isChargeBoosting && this.chargeLevel >= this.maxChargeLevel;
                
                // Update movement flags
                this.flags.grounded = this.isGrounded;
                this.flags.raising = this.stateMachine.currentState === 'jumping' && this.stateMachine.stateTimer < 300;
                this.flags.falling = this.stateMachine.currentState === 'jumping' && this.stateMachine.stateTimer >= 300;
            }
        }
        
        // Game configuration
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'gameContainer',
            backgroundColor: '#2c3e50',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 800 },
                    debug: false
                }
            },
            scene: StateMachineTestScene
        };
        
        // Start the game
        const game = new Phaser.Game(config);
    </script>
</body>
</html>
